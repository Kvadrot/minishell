👉
void rl_clear_history (void):

Clear the history list by deleting all of the entries, in the same
manner as the History library’s clear_history() function.
This differs from clear_history because it frees private data
Readline saves in the history list.


👉
int rl_on_new_line (void);

Tell the update functions that we have moved onto a new (empty) line,
usually after outputting a newline.


👉
void rl_replace_line (const char *text, int clear_undo):

Replace the contents of rl_line_buffer with text. The point and mark
are preserved, if possible. If clear_undo is non-zero, the undo list
associated with the current line is cleared.


👉
void rl_redisplay (void):

Change what’s displayed on the screen to reflect the current contents
of rl_line_buffer.


👉
void add_history (char *string):

Place string at the end of the history list. The associated data
field (if any) is set to NULL.

if (line_read && *line_read)
    add_history(line_read);


👉
#include <unistd.h>

int access(const char *pathname, int mode):

pathname: A pointer to a string that represents the path to the file or directory you want to check.

mode: An integer that specifies the accessibility check(s) you want to perform. It can be a
bitwise OR of the following constants:

F_OK: Check for the existence of the file.
R_OK: Check for read permission.
W_OK: Check for write permission.
X_OK: Check for execute permission.

Return Value
0: The file or directory is accessible as per the specified mode.
-1: The file or directory is not accessible, and errno is set to indicate the error.

Common Errors (errno Values)
EACCES: Permission is denied for the requested access.
EFAULT: The pathname points to an invalid address.
ENOENT: The file does not exist.
ENOTDIR: A component of the path is not a directory.

Lets consider an example where we check if a file exists and if it is readable.

#include <stdio.h>
#include <unistd.h>

int main() {
    const char *filename = "example.txt";

    // Check if the file exists
    if (access(filename, F_OK) == 0)
	{
        printf("%s exists.\n", filename);
        // Check if the file is readable
        if (access(filename, R_OK) == 0)
            printf("%s is readable.\n", filename);
        else
            printf("%s is not readable.\n", filename);
    }
	else
        printf("%s does not exist.\n", filename);
    return (0);
}

Bitwise OR Example
If you want to check for multiple permissions at once (e.g., read and write), you can
combine the flags using the bitwise OR (|) operator:

if (access(filename, R_OK | W_OK) == 0)
    printf("%s is readable and writable.\n", filename);
else
    printf("%s is not accessible for read and write.\n", filename);




👉
pid_t fork(void):

Return Value
pid_t: This is a data type that represents process IDs. The return value of fork is
different for the parent and child processes:

0: Returned to the child process.
> 0: The process ID (PID) of the child process, returned to the parent process.
-1: If an error occurs, fork returns -1 to the parent process, and no child process is created.

Key Points to Remember
Concurrency: The parent and child processes run concurrently and independently. They share
the same code but have separate memory spaces.

Shared Data: Variables in the parent and child processes are copied, not shared.
Changes in the child process do not affect the parent process and vice versa.

Execution Order: The order of execution between the parent and child processes is not predictable.
Orphan and Zombie Processes: If a parent process terminates before the child, the child becomes
an orphan process, which is adopted by the init process. If a child process terminates before
the parent and the parent does not call wait(), the child becomes a zombie process until the parent
reads its exit status.

int main()
{
    pid_t pid = fork();

    if (pid == 0)
	{
        // Child process
        printf("Child process, PID: %d\n", getpid());
    }
	else
	{
        // Parent process
        wait(NULL);  // Wait for child process to finish
        printf("Parent process, child's PID: %d\n", pid);
    }
    return 0;
}


👉
pid_t wait(int *wstatus);

wstatus: A pointer to an integer where the exit status of the child process is stored. If you
dont care about the status, you can pass NULL.

Return Value
> 0: The process ID of the terminated child.
-1: If there are no child processes or an error occurs, wait returns -1 and sets errno to
indicate the error.

int main()
{
    pid_t pid = fork();

    if (pid == 0)
	{
        // Child process
        printf("Child process, PID: %d\n", getpid());
        return 42;  // Child exits with status 42
    }
	else
	{
        // Parent process
		// wait(&wstatus): The parent process waits for the child to terminate.
		// The child's exit status is stored in wstatus.
        int wstatus;
        pid_t child_pid = wait(&wstatus);
		// WIFEXITED(wstatus): Checks if the child process terminated normally.
		// WEXITSTATUS(wstatus): Extracts the exit status of the child.
        if (WIFEXITED(wstatus))
            printf("Parent: Child %d exited with status %d\n", child_pid, WEXITSTATUS(wstatus));
    }
    return 0;
}




👉
pid_t waitpid(pid_t pid, int *wstatus, int options);

The waitpid function is more versatile than wait. It allows the parent process to wait
for a specific child process or to specify additional options.

pid: Specifies which child process to wait for:

pid > 0: Waits for the child with the given process ID.
pid = 0: Waits for any child in the same process group as the calling process.
pid < -1: Waits for any child whose process group ID is |pid|.
pid = -1: Waits for any child process (equivalent to wait).
wstatus: A pointer to an integer where the exit status is stored (same as wait).

options: A bitmask that modifies the behavior of waitpid. Some common options include:

WNOHANG: Returns immediately if no child has exited.
WUNTRACED: Also returns if a child has stopped (not just terminated).
WCONTINUED: Returns if a stopped child has been resumed by SIGCONT.

Return Value
> 0: The process ID of the child whose state has changed.
0: If WNOHANG was specified and no child exited.
-1: If an error occurs, waitpid returns -1 and sets errno.

int main()
{
    pid_t pid = fork();

    if (pid == 0)
	{
        // Child process
        printf("Child process, PID: %d\n", getpid());
        return 42;  // Child exits with status 42
    }
	else
	{
        // Parent process
        int wstatus;
		// waitpid(pid, &wstatus, 0): The parent waits specifically for the child 
		// with the given PID to terminate.
        pid_t child_pid = waitpid(pid, &wstatus, 0);

		// WIFEXITED(wstatus) and WEXITSTATUS(wstatus): Used to check the exit status
		// of the child, similar to wait.
        if (child_pid > 0)
            if (WIFEXITED(wstatus))
                printf("Parent: Child %d exited with status %d\n", child_pid, WEXITSTATUS(wstatus));
		else
            printf("waitpid() failed.\n");
    }
    return (0);
}

SUMMARY:

wait: Simple, waits for any child process to terminate.
waitpid: More flexible, can wait for a specific child and support non-blocking behavior
with options like WNOHANG.
Key Use: Both functions are crucial for process management in C, especially to prevent
zombie processes by ensuring the parent retrieves the exit status of its child processes.


👉
The wait3 and wait4 functions are extensions of the wait and waitpid functions, providing
additional information about the child process resource usage. They are less commonly used
than wait and waitpid, but they offer more detailed information, such as CPU time consumed by
the child process.

pid_t wait3(int *wstatus, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);

pid: Specifies which child process to wait for, similar to waitpid:
	pid > 0: Waits for the child with the specified PID.
	pid = 0: Waits for any child in the same process group.
	pid < -1: Waits for any child in the process group |pid|.
	pid = -1: Waits for any child process (similar to wait).
wstatus: A pointer to an integer where the exit status of the child process is stored.
It can be NULL if you do not need the exit status.
options: Options that modify the behavior of wait3. These options are the same as those
used with waitpid, like WNOHANG, WUNTRACED, and WCONTINUED.
rusage: A pointer to a struct rusage that will hold resource usage statistics for the child proc

struct rusage {
    struct timeval ru_utime; /* user CPU time used */
    struct timeval ru_stime; /* system CPU time used */
    // Additional fields for other resource usage metrics
};



👉
#include <unistd.h>
char *getcwd(char *buf, size_t size):

DESCRIPTION
	These  functions return a null-terminated string containing an absolute pathname that is the
	current working directory of the calling process. The pathname is returned as the function
	result and via the argument buf, if present.

	The  getcwd()  function  copies an absolute pathname of the current working directory to the
	array pointed to by buf, which is of length size.

	If the length of the absolute pathname of the current working directory, including the
	terminating null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE; an
	application should check for this error, and allocate a larger buffer if necessary.

	getcwd() allocates the buffer dynamically using malloc(3) if buf is NULL. In this case, the
	allocated buffer has the length	size unless size is zero, when buf is allocated as big as necessary.   The  caller  should
	The  caller  should free(3) the returned buffer.

RETURN VALUE
	On success, these functions return a pointer to a string containing the pathname of the current
	working directory. In the case of getcwd() and getwd() this is the same value as buf.

	On failure, these functions return NULL, and errno is set to indicate the error.  The contents
	of the array pointed to by buf are undefined on error.

ERRORS
	EACCES Permission to read or search a component of the filename was denied.

	EFAULT buf points to a bad address.

	EINVAL The size argument is zero and buf is not a null pointer.

	EINVAL getwd(): buf is NULL.

	ENAMETOOLONG
			getwd(): The size of the null-terminated absolute pathname  string  exceeds  PATH_MAX
			bytes.

	ENOENT The current working directory has been unlinked.

	ENOMEM Out of memory.

	ERANGE	The size argument is less than the length of the absolute pathname of the working
			directory, including the terminating null byte.  You need to allocate  a  bigger  array
			and try again



👉
#include <unistd.h>
int chdir(const char *path);

chdir — change working directory

DESCRIPTION
	The  chdir() function shall cause the directory named by the pathname pointed to by the
	path argument to become the current working directory; that is, the starting point  for
	path searches for pathnames not beginning with '/'.

RETURN VALUE
	Upon  successful  completion, 0 shall be returned. Otherwise, -1 shall be returned, the
	current working directory shall remain unchanged, and errno shall be  set  to  indicate
	the error.
ERRORS
	The chdir() function shall fail if:

	EACCES Search permission is denied for any component of the pathname.

	ELOOP  A  loop exists in symbolic links encountered during resolution of the path argu‐
			ment.

	ENAMETOOLONG
			The length of a component of a pathname is longer than {NAME_MAX}.

	ENOENT A component of path does not name an existing directory  or  path  is  an  empty
			string.

	ENOTDIR
			A  component  of the pathname names an existing file that is neither a directory
			nor a symbolic link to a directory.

	The chdir() function may fail if:

	ELOOP  More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the
			path argument.

	ENAMETOOLONG
			The  length  of  a pathname exceeds {PATH_MAX}, or pathname resolution of a sym‐
			bolic  link  produced  an  intermediate  result  with  a  length  that   exceeds
			{PATH_MAX}.

EXAMPLES
	The  following example makes the value pointed to by directory, /tmp, the current
	working directory.

		#include <unistd.h>
		...
		char *directory = "/tmp";
		int ret;

		ret = chdir (directory);

RATIONALE
	The chdir() function only affects the working directory of the current process.



👉
#include <sys/stat.h>
int stat(const char *restrict path, struct stat *restrict buf);

stat — get file status

DESCRIPTION
	The  stat()  function shall obtain information about the named file and write it to the
	area pointed to by the buf argument. The path argument points to a  pathname  naming  a
	file.  Read,  write, or execute permission of the named file is not required.
	An implementation that provides additional or alternate file access control mechanisms
	may, under implementation-defined conditions, cause stat() to fail. In particular, the system
	may deny the existence of the file specified by path.

	If the named file is a symbolic link, the stat() function shall continue pathname resolution
	using the contents of the symbolic link, and shall return information pertaining to the
	resulting file if the file exists.

	The buf argument is a pointer to a stat  structure,  as  defined  in  the  <sys/stat.h>
	header, into which information is placed concerning the file.

RETURN VALUE
	Upon successful completion, these functions shall return 0.  Otherwise, these functions
	shall return -1 and set errno to indicate the error.

ERRORS
	These functions shall fail if:

	EACCES Search permission is denied for a component of the path prefix.

	EIO    An error occurred while reading from the file system.

	ELOOP  A  loop exists in symbolic links encountered during resolution of the path argument.

	ENAMETOOLONG
			The length of a component of a pathname is longer than {NAME_MAX}.

	ENOENT A component of path does not name an existing file or path is an empty string.

	ENOTDIR
			A component of the path prefix names an existing file that is neither  a  directory
			nor a symbolic link to a directory, or the path argument contains at least 
			one non-<slash> character and ends with one or more trailing <slash>  characters
			and  the last pathname component names an existing file that is neither a directory
			nor a symbolic link to a directory.

	EOVERFLOW
			The file size in bytes or the number of blocks allocated to the file or the file
			serial  number  cannot  be  represented correctly in the structure pointed to by
			buf.

EXAMPLES
	The  following  example  shows  how  to obtain file status information for a file named
	/home/cnd/mod1.  The structure variable buffer is defined for the stat structure.

		struct stat buffer;
		int         status;
		...
		status = stat("/home/cnd/mod1", &buffer);

   
	The following example fragment gets status information for each entry in  a  directory.
	The  call  to the stat() function stores file information in the stat structure pointed
	to by statbuf.  The lines that follow the stat() call format the  fields  in  the  stat
	structure for presentation to the user of the program.
	
	   struct dirent  *dp;
		struct stat     statbuf;
		struct passwd  *pwd;
		struct group   *grp;
		struct tm      *tm;
		char            datestring[256];
		...
		/* Loop through directory entries. */
		while ((dp = readdir(dir)) != NULL) {

			/* Get entry's information. */
			if (stat(dp->d_name, &statbuf) == -1)
				continue;

			/* Print out type, permissions, and number of links. */
			printf("%10.10s", sperm (statbuf.st_mode));
			printf("%4d", statbuf.st_nlink);

			/* Print out owner's name if it is found using getpwuid(). */
			if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
				printf(" %-8.8s", pwd->pw_name);
			else
				printf(" %-8d", statbuf.st_uid);

			/* Print out group name if it is found using getgrgid(). */
			if ((grp = getgrgid(statbuf.st_gid)) != NULL)
				printf(" %-8.8s", grp->gr_name);
			else
				printf(" %-8d", statbuf.st_gid);

			/* Print size of file. */
			printf(" %9jd", (intmax_t)statbuf.st_size);

			tm = localtime(&statbuf.st_mtime);

			/* Get localized date string. */
			strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);

			printf(" %s %s\n", datestring, dp->d_name);
		}

In C, the functions stat, lstat, and fstat are used to retrieve information about files,
but they differ in how they handle symbolic links and file descriptors. Heres a breakdown:

👉stat
Purpose: Retrieves information about the file specified by a given path.
Behavior: If the path provided is a symbolic link, stat follows the link and returns
information about the target file (i.e., the file the link points to).

Usage Example:

struct stat fileStat;
if (stat("/path/to/file", &fileStat) == 0)
{
    // Successfully retrieved information about the file
}

👉lstat
Purpose: Similar to stat, but it does not follow symbolic links.
Behavior: If the path provided is a symbolic link, lstat returns information about the
link itself, not the file it points to.

Usage Example:

struct stat fileStat;
if (lstat("/path/to/file_or_symlink", &fileStat) == 0)
{
    // Successfully retrieved information about the file or symbolic link
}

👉fstat
Purpose: Retrieves information about a file using an open file descriptor instead of a file path.
Behavior: The file descriptor refers to an already opened file, and fstat returns information about that file. 
It does not deal with symbolic links directly because the file has already been opened.
Usage Example:

int fd = open("/path/to/file", O_RDONLY);
struct stat fileStat;
if (fstat(fd, &fileStat) == 0)
{
    // Successfully retrieved information about the file associated with the file descriptor
}
close(fd);

Summary
stat: Follows symbolic links to retrieve information about the target file.
lstat: Retrieves information about the symbolic link itself, not the target file.
fstat: Retrieves information about a file through an open file descriptor.


👉
DIR *opendir(const char *name);

DESCRIPTION
	The  opendir()  function opens a directory stream corresponding to the directory name, and
	returns a pointer to the directory stream.  The stream is positioned at the first entry in
	the directory.

	The  fdopendir() function is like opendir(), but returns a directory stream for the
	directory referred to by the open file descriptor fd.  After a successful call to  fdopendir(),
	fd  is  used internally by the implementation, and should not otherwise be used by the application.

RETURN VALUE
	The opendir() and fdopendir() functions return a pointer to the directory stream. 
	On error, NULL is returned, and errno is set appropriately.

ERRORS
	EACCES Permission denied.

	EBADF  fd is not a valid file descriptor opened for reading.

	EMFILE The per-process limit on the number of open file descriptors has been reached.

	ENFILE The system-wide limit on the total number of open files has been reached.

	ENOENT Directory does not exist, or name is an empty string.

	ENOMEM Insufficient memory to complete the operation.

	ENOTDIR
			name is not a directory.



👉
struct dirent *readdir(DIR *dirp);

DESCRIPTION
	The  readdir()  function returns a pointer to a dirent structure representing the next
	directory entry in the directory stream pointed to by dirp.  It returns NULL on reaching the
	end of the directory stream or if an error occurred.

	In the glibc implementation, the dirent structure is defined as follows:

		struct dirent {
			ino_t          d_ino;       /* Inode number */
			char           d_name[256]; /* Null-terminated filename */
		};

	The only fields in the dirent structure that are mandated by POSIX.1 are d_name and d_ino.
	The other fields are unstandardized, and not present on all systems.
	When  a  suitable  feature test macro is defined, glibc  defines  the
	following macro constants for the value returned in d_type:

		DT_BLK      This is a block device.

		DT_CHR      This is a character device.

		DT_DIR      This is a directory.

		DT_FIFO     This is a named pipe (FIFO).

		DT_LNK      This is a symbolic link.

		DT_REG      This is a regular file.

		DT_SOCK     This is a UNIX domain socket.

		DT_UNKNOWN  The file type could not be determined.

	Currently, only some filesystems have full support for returning the file type in d_type.
	All applications must properly handle a return of DT_UNKNOWN.

       d_name This field contains the null terminated filename.

       The data returned by readdir() may be overwritten by subsequent calls to readdir() for the
       same directory stream.

RETURN VALUE
	On success, readdir() returns a pointer to a dirent structure. (This  structure  may  be
	statically allocated; do not attempt to free(3) it.)

	If  the end of the directory stream is reached, NULL is returned and errno is not changed.
	If an error occurs, NULL is returned and errno is set appropriately.  To  distinguish  end
	of  stream  from  an  error, set errno to zero before calling readdir() and then check the
	value of errno if NULL is returned.

ERRORS
	EBADF  Invalid directory stream descriptor dirp.




👉
int closedir(DIR *dirp);

closedir - close a directory

DESCRIPTION
	The closedir() function closes the directory stream associated with dirp. A successful
	call to closedir() also closes the underlying file descriptor associated with dirp. The
	directory stream descriptor dirp is not available after this call.

RETURN VALUE
	The  closedir() function returns 0 on success.  On error, -1 is returned, and errno is set
	appropriately.

ERRORS
	EBADF  Invalid directory stream descriptor dirp.



👉
int isatty(int fd);

isatty - test whether a file descriptor refers to a terminal

DESCRIPTION
	The isatty() function tests whether fd is an open file descriptor referring to a terminal.

RETURN VALUE
	isatty()  returns  1 if fd is an open file descriptor referring to a terminal; otherwise 0
	is returned, and errno is set to indicate the error.

ERRORS
	EBADF  fd is not a valid file descriptor.

	ENOTTY fd refers to a file other than a terminal.



👉
char *ttyname(int fd);

ttyname - return name of a terminal

DESCRIPTION
	The  function  ttyname() returns a pointer to the null-terminated pathname of the terminal
	device that is open on the file descriptor fd, or NULL on error (for example, if fd is not
	connected to a terminal).  The return value may point to static data, possibly overwritten
	by the next call.

RETURN VALUE
	The  function ttyname() returns a pointer to a pathname on success.  On error, NULL is
	returned, and errno is set appropriately.

ERRORS
	EBADF  Bad file descriptor.

	ENODEV fd refers to a slave pseudoterminal device but the corresponding pathname could not
			be found.

	ENOTTY fd does not refer to a terminal device.



👉
int ttyslot(void);

ttyslot - find the slot of the current users terminal in some file

DESCRIPTION
	The legacy function ttyslot() returns the index of the current users entry in some file.
	Thus, the function ttyslot() returns the index of the controlling terminal of the  calling
	process  in  the  file /etc/ttys, and that is (usually) the same as the index of the entry
	for the current user in the file /etc/utmp.  BSD still has the /etc/ttys file, but  System
	V-like systems do not, and hence cannot refer to it.  Thus, on such systems the documentation
	says that ttyslot() returns the current users index  in  the  user  accounting  data base.

RETURN VALUE
	If successful, this function returns the slot number.  On error (e.g., if none of the file
	descriptors 0, 1 or 2 is associated with a terminal that occurs in this data base)
	it returns 0 on UNIX V6 and V7 and BSD-like systems, but -1 on System V-like systems.



👉
int ioctl(int fildes, int request, ... /* arg */);

ioctl — control a STREAMS device (STREAMS)

DESCRIPTION
	The  ioctl()  function shall perform a variety of control functions on STREAMS devices. 
	The request  argument  and  an  optional  third argument (with varying type) shall be
	passed to and interpreted by the appropriate part of the STREAM associated with fildes.

	The fildes argument is an open file descriptor that refers to a device.

	The request argument selects the control function to be performed and shall depend  on  the
	STREAMS device being addressed.

	The  arg argument represents additional information that is needed by this specific STREAMS
	device to perform the requested function. The type of arg depends upon the particular
	control request, but it shall be either an integer or a pointer to a device-specific data
	structure.

	The ioctl() commands applicable to STREAMS, their arguments, and error conditions that apply
	to each individual command are described below.

	//	man 3 ioctl for all the commands

	RETURN VALUE
       Upon successful completion, ioctl() shall return a value other than -1  that  depends  upon
       the  STREAMS  device control function. Otherwise, it shall return -1 and set errno to
	   indicate the error.

	ERRORS
       Under the following general conditions, ioctl() shall fail if:

       EBADF  The fildes argument is not a valid open file descriptor.

       EINTR  A signal was caught during the ioctl() operation.

       EINVAL The STREAM or multiplexer referenced by fildes is linked  (directly  or  indirectly)
              downstream from a multiplexer.

       If an underlying device driver detects an error, then ioctl() shall fail if:

       EINVAL The request or arg argument is not valid for this device.

       EIO    Some physical I/O error has occurred.

       ENOTTY The  file  associated  with the fildes argument is not a STREAMS device that accepts
              control functions.

       ENXIO  The request and arg arguments are valid for this device driver, but the service
				requested cannot be performed on this particular sub-device.

       ENODEV The  fildes  argument refers to a valid STREAMS device, but the corresponding device
              driver does not support the ioctl() function.

       If a STREAM is connected downstream from a multiplexer, any ioctl() command except I_UNLINK
       and I_PUNLINK shall set errno to [EINVAL].



👉
char *getenv(const char *name);

getenv, secure_getenv - get an environment variable

DESCRIPTION
	The  getenv() function searches the environment list to find the environment variable name,
	and returns a pointer to the corresponding value string.

	The GNU-specific secure_getenv() function is just like getenv() except that it returns NULL
	in  cases where "secure execution" is required.  Secure execution is required if one of the
	following conditions was true when the program run by the calling process was loaded:

	*  the processes effective user ID did not match its real user ID or the  processes
		effective group ID did not match its real group ID (typically this is the result of executing
		a set-user-ID or set-group-ID program);

	*  the effective capability bit was set on the executable file; or

	*  the process has a nonempty permitted capability set.

	Secure execution may also be required if triggered by some Linux security modules.

	The secure_getenv() function is intended for use in general-purpose libraries to avoid
	vulnerabilities  that could occur if set-user-ID or set-group-ID programs accidentally trusted
	the environment.

RETURN VALUE
	The getenv() function returns a pointer to the value in the environment, or NULL  if  there
	is no match.
